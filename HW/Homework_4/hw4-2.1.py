"""
验证 n=12 的情况为正20面体分布.
验证方法：求出rij，若为正二十面体，则在 66 个rij中，最小的30个应相等.
"""

from math import sin


# n=12 时势能取极小值的电子分布
y = [[2.5059274348395], [2.654193413965302], [0.4873992366784594], [1.6865909563235035], [0.9205513476454892], [2.0241716940999512], [0.635665205524695], [1.5828862144630216], [1.5587059542463775], [2.2210414792384303], [1.1174206536808424], [1.4550023325809835], [3.7828830156747], [0.963300105332811], [4.10488890628057], [0.2284163144177245], [2.29666860177838], [2.390580151588263], [0.6412881970277896], [1.3337286060432552], [4.475321739374854], [5.438262346437221], [5.532172162057909], [3.370009043474266]]
x = [y[i][0] for i in range(24)]  # 把二维数组转化为一维


def rij(thetai, thetaj, phii, phij):
    """i,j两点间距（球坐标）.

    Args:
        theta_i, theta_j, phi_i, phi_j: i,j点坐标.

    Returns:
        r_ij: 两点间距.
    """
    r_ij = (sin((thetai - thetaj) / 2)**2 + sin(thetai) * sin(thetaj) * (sin(
        (phii - phij) / 2)**2))**0.5 * 2
    return r_ij


def rij_all(_x):
    """全部的rij，组成一个list"""
    r = []
    n = int(len(_x) / 2)
    for i in range(n):
        for j in range(i):
            r.append(rij(_x[i], _x[j], _x[i + n], _x[j + n]))
    return r


r = rij_all(x)
r.sort()
print("rij中，按由小到大排列后，第30个与第1个的相对偏差：delta = (r_{30}-r_1)/(r_1) = ", r[29] - r[0])
print("rij前30项数据如下：")
print(r[0:30])
file = open('data2.1.txt', 'w')
file.write('rij中，按由小到大排列\n第30个与第1个的相对偏差：delta = (r_30-r_1)/r_1 = ' + str(r[29] - r[0]) + '\n')
file.write('rij前30项数据如下：\n' + str(r[0:30]))
file.close()
